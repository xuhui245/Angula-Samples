{
  "_args": [
    [
      {
        "raw": "mongoose-unique-validator@^1.0.2",
        "scope": null,
        "escapedName": "mongoose-unique-validator",
        "name": "mongoose-unique-validator",
        "rawSpec": "^1.0.2",
        "spec": ">=1.0.2 <2.0.0",
        "type": "range"
      },
      "C:\\Users\\xjiang\\Desktop\\Angular2\\Angular_2"
    ]
  ],
  "_from": "mongoose-unique-validator@>=1.0.2 <2.0.0",
  "_id": "mongoose-unique-validator@1.0.5",
  "_inCache": true,
  "_location": "/mongoose-unique-validator",
  "_nodeVersion": "7.6.0",
  "_npmOperationalInternal": {
    "host": "packages-18-east.internal.npmjs.com",
    "tmp": "tmp/mongoose-unique-validator-1.0.5.tgz_1490135317036_0.55056945187971"
  },
  "_npmUser": {
    "name": "viveleroi",
    "email": "botsko@gmail.com"
  },
  "_npmVersion": "4.1.2",
  "_phantomChildren": {},
  "_requested": {
    "raw": "mongoose-unique-validator@^1.0.2",
    "scope": null,
    "escapedName": "mongoose-unique-validator",
    "name": "mongoose-unique-validator",
    "rawSpec": "^1.0.2",
    "spec": ">=1.0.2 <2.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/mongoose-unique-validator/-/mongoose-unique-validator-1.0.5.tgz",
  "_shasum": "591872fafe0830939f0b756b6554243c93163aa0",
  "_shrinkwrap": null,
  "_spec": "mongoose-unique-validator@^1.0.2",
  "_where": "C:\\Users\\xjiang\\Desktop\\Angular2\\Angular_2",
  "author": {
    "name": "Blake Haswell",
    "email": "haswell00@gmail.com",
    "url": "http://blakehaswell.com/"
  },
  "bugs": {
    "url": "https://github.com/blakehaswell/mongoose-unique-validator/issues"
  },
  "contributors": [
    {
      "name": "Mike Botsko",
      "email": "botsko@gmail.com"
    }
  ],
  "dependencies": {
    "lodash.foreach": "^4.1.0",
    "lodash.get": "^4.0.2"
  },
  "description": "mongoose-unique-validator is a plugin which adds pre-save validation for unique fields within a Mongoose schema.",
  "devDependencies": {
    "bluebird": "^3.2.2",
    "chai": "^3.3.0",
    "eslint": "^3.10.2",
    "mocha": "^3.1.2"
  },
  "directories": {},
  "dist": {
    "shasum": "591872fafe0830939f0b756b6554243c93163aa0",
    "tarball": "https://registry.npmjs.org/mongoose-unique-validator/-/mongoose-unique-validator-1.0.5.tgz"
  },
  "gitHead": "3b4408a68479ae398827e83082271887218878e2",
  "homepage": "https://github.com/blakehaswell/mongoose-unique-validator#readme",
  "keywords": [
    "mongoose",
    "unique",
    "validator"
  ],
  "license": "MIT",
  "main": "index.js",
  "maintainers": [
    {
      "name": "blakehaswell",
      "email": "haswell00@gmail.com"
    },
    {
      "name": "viveleroi",
      "email": "botsko@gmail.com"
    }
  ],
  "name": "mongoose-unique-validator",
  "optionalDependencies": {},
  "peerDependencies": {
    "mongoose": "^4.9.0"
  },
  "readme": "mongoose-unique-validator\n=========================\n\n[![Build Status](https://travis-ci.org/blakehaswell/mongoose-unique-validator.svg)](https://travis-ci.org/blakehaswell/mongoose-unique-validator)\n\nmongoose-unique-validator is a plugin which adds pre-save validation for unique fields within a Mongoose schema.\n\nThis makes error handling much easier, since you will get a Mongoose validation error when you attempt to violate a\n[unique constraint](http://mongoosejs.com/docs/api.html#schematype_SchemaType-unique), rather than an E11000 error\nfrom MongoDB.\n\nUsage\n-----\n\n```\nnpm install mongoose-unique-validator\n```\n\nThen, simply apply the plugin to your schema:\n\n```js\nvar mongoose = require('mongoose');\nvar uniqueValidator = require('mongoose-unique-validator');\n\nvar mySchema = mongoose.Schema(/* put your schema definition here */);\nmySchema.plugin(uniqueValidator);\n```\n\nExample\n-------\n\nLetâ€™s say you have a user schema. You can easily add validation for the unique constraints in this schema by applying\nthe `uniqueValidator` plugin to your user schema:\n\n```js\nvar mongoose = require('mongoose');\nvar uniqueValidator = require('mongoose-unique-validator');\n\n// Define your schema as normal.\nvar userSchema = mongoose.Schema({\n    username: { type: String, required: true, unique: true },\n    email: { type: String, index: true, unique: true, required: true },\n    password: { type: String, required: true }\n});\n\n// Apply the uniqueValidator plugin to userSchema.\nuserSchema.plugin(uniqueValidator);\n```\n\nNow when you try to save a user, the unique validator will check for duplicate database entries and report them just\nlike any other validation error:\n\n```js\nvar user = new User({ username: 'JohnSmith', email: 'john.smith@gmail.com', password: 'j0hnNYb0i' });\nuser.save(function (err) {\n    console.log(err);\n});\n```\n\n```js\n{\n    message: 'Validation failed',\n    name: 'ValidationError',\n    errors: {\n        username: {\n            message: 'Error, expected `username` to be unique. Value: `JohnSmith`',\n            name: 'ValidatorError',\n            kind: 'unique',\n            path: 'username',\n            value: 'JohnSmith'\n        }\n    }\n}\n```\n\nFind + Updates\n--------------\n\nWhen using `findOneAndUpdate` and related methods, mongoose doesn't automatically run validation. To trigger this,\nyou need to pass a configuration object. For technical reasons, this plugin requires that you also set the context\noption to `query`.\n\n`{ runValidators: true, context: 'query' }`\n\nA full example:\n\n```js\nUser.findOneAndUpdate(\n    { email: 'old-email@example.com' },\n    { email: 'new-email@example.com' },\n    { runValidators: true, context: 'query' },\n    function(err) {\n        // ...\n    }\n)\n```\n\nCustom Error Types\n------------------\n\nYou can pass through a custom error type as part of the optional `options` argument:\n\n```js\nuserSchema.plugin(uniqueValidator, { type: 'mongoose-unique-validator' });\n```\n\nAfter running the above example the output will be:\n\n```js\n{\n    message: 'Validation failed',\n    name: 'ValidationError',\n    errors: {\n        username: {\n            message: 'Error, expected `username` to be unique. Value: `JohnSmith`',\n            name: 'ValidatorError',\n            kind: 'mongoose-unique-validator',\n            path: 'username',\n            value: 'JohnSmith'\n        }\n    }\n}\n```\n\nCustom Error Messages\n---------------------\n\nYou can pass through a custom error message as part of the optional `options` argument:\n\n```js\nuserSchema.plugin(uniqueValidator, { message: 'Error, expected {PATH} to be unique.' });\n```\n\nYou have access to all of the standard Mongoose error message templating:\n\n*   `{PATH}`\n*   `{VALUE}`\n*   `{TYPE}`\n\n\nCase Insensitive\n---------------------\n\nFor case-insensitive matches, include the `uniqueCaseInsensitive` option in your schema. Queries will treat `john.smith@gmail.com` and `John.Smith@gmail.com` as duplicates.\n\n```js\nvar userSchema = mongoose.Schema({\n    username: { type: String, required: true, unique: true },\n    email: { type: String, index: true, unique: true, required: true, uniqueCaseInsensitive: true },\n    password: { type: String, required: true }\n});\n```\n\n\nCaveats\n-------\n\nBecause we rely on async operations to verify whether a document exists in the database, it's possible for two queries to execute at the same time, both get 0 back, and then both insert into MongoDB.\n\nOutside of automatically locking the collection or forcing a single connection, there's no real solution.\n\nFor most of our users this won't be a problem, but is an edge case to be aware of.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/blakehaswell/mongoose-unique-validator.git"
  },
  "scripts": {
    "lint": "eslint index.js test",
    "test": "mocha test && ./node_modules/eslint/bin/eslint.js index.js test"
  },
  "version": "1.0.5"
}
